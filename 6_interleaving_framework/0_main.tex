\chapter{Interleaving Planning and Control}
\label{chap:interleaving}

The previous chapters have focused on local methods for solving tasks. While we've shown that these methods are capable of performing interesting tasks, they are unable to escape from local minima due to their very design. This chapter is focused on a method to overcome this limitation by adding planning to the set of tools that we can apply to a given task.

One of the challenges in planning for deformable object manipulation is the high number of degrees of freedom involved; even approximating the configuration of a piece of cloth in 3D with a 4 $\times$ 4 grid results in a 48 degree of freedom configuration space. In addition, the dynamics of the deformable object are difficult to model \citep{Essahbi2012}; even with high-fidelity modeling and simulation, planning for an individual task can take hours \citep{Bai2016}. Local controllers on the other hand are able to very efficiently generate motion, however, they are only able to successfully complete a task when the initial configuration is in the ``attraction basin'' of the goal as seen in Chapter~\ref{chap:local_control}.

The central question we address in this chapter is how can we combine the strengths of global planning with the strengths of local control while mitigating the weakness of each? We propose a framework for interleaving planning and control which uses global planning to generate gross motion of the deformable object, and a local controller to refine the configuration of the deformable object within the local neighborhood. By separating planning from control we are able to use different representations of the deformable object, each suited to efficient computation for their respective roles. In order to determine when to use each component, we introduce a novel deadlock prediction algorithm that is inspired by topologically-based motion planning methods \cite{Jaillet2008, Bhattacharya2012}. By answering the question ``Will the local controller get stuck?'' we can predict if the local controller will be unable to achieve the task from the current configuration. If we predict that the controller will get stuck we can then invoke the global planner, moving the deformable object into a new neighbourhood from which the local controller may be able to succeed. The key to our efficient prediction is forward-propagating only the stretching constraint, assuming the object will otherwise comply to contact.

We seek to solve problems for one-dimensional and two-dimensional deformable objects (i.e. rope and cloth) where we need to arrange the object in a particular way (e.g. covering a table with a tablecloth) but where there is also complex environment geometry preventing us from directly completing the task. While we cannot claim to solve all problems in this class (in particular in environments where the deformable object can be snagged), we can still solve practical problems where the path of the deformable object is obstructed by obstacles. In this work we restrict our focus to controllers of the form described in Section~\ref{sec:local_control}, and tasks suited to these controllers. Examples of these types of tasks are shown in Figure~\ref{fig:example_tasks}. In our experiments we show that this iterative method of interleaving planning and control is able to successfully perform several interesting tasks where our planner or controller alone are unable to succeed.

\begin{figure}[h]
    \centering
    \includegraphics[trim={5cm 6cm 3cm 4cm},clip,width=0.245\textwidth,height=1.5in,keepaspectratio]{single_pole_starting_configuration}\hfill
    \includegraphics[trim={2cm 3cm 6cm 7cm},clip,width=0.245\textwidth,height=1.5in,keepaspectratio]{double_slit_starting_configuration}\hfill
    \includegraphics[trim={0cm 1cm 0cm 1cm},clip,width=0.245\textwidth,height=1.5in,keepaspectratio]{rope_maze_starting_configuration}\hfill
    \includegraphics[trim={1.5cm 0cm 0.6cm 0cm},clip,width=0.245\textwidth,height=1.5in,keepaspectratio]{live_robot_starting_configuration}%
    \caption{Four example manipulation tasks for our framework. In the first two tasks, the objective is to cover the surface of the table (indicated by the red lines) with the cloth (shown in green). In the first task, the grippers (shown in blue) can freely move however the cloth is obstructed by a pillar. In the second task, the grippers must pass through a narrow passage before the table can be covered. In the third task, the robot must navigate a rope (shown in green in the top left corner) through a three-dimensional maze before covering the red points in the top right corner. The maze consists of top and bottom layers (purple and green, respectively). The rope starts in the bottom layer and must move to the target on the top layer through an opening (bottom left or bottom right). For the fourth task, the physical robot must move the cloth from the far side of an obstacle to the region marked in pink near the base of the robot.}
    \label{fig:example_tasks}
\end{figure}

Our contributions are: (1) A novel deadlock prediction algorithm to determine when a global planner is needed; (2) An efficient and probabilistically-complete global planner for rope and cloth manipulation tasks; and (3) A framework to combine local control and global motion planning to leverage the strengths of each while mitigating their weaknesses. We present experiments in both a simulated environment and on a physical robot. Our results suggest that our planner can efficiently find paths, taking under a second on average to generate a feasible path in three out of four simulated scenarios. The physical experiment shows that our framework is able to effectively perform tasks in the real world, where reachability and dual-arm constraints make the planning more difficult.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Problem Statement}
\label{sec:main_problem_statement}

Define the robot configuration space to be $\robotCspace$. We assume that the robot configuration can be measured exactly. Denote an individual robot configuration as $\robotconfig \in \robotCspace$. This set can be partitioned into a valid and invalid set. The valid set is referred to as $\robotCvalid$, and is the set of configurations where the robot is not in collision with the static geometry of the world. The invalid set is referred to as $\robotCinvalid = \robotCspace \setminus \robotCvalid$.

We assume that our model of the robot is purely kinematic, with no higher order dynamics. Previous chapters assumed an arbitrary number of grippers; in this chapter we restrict the problem to cases where two end-effectors are rigidly attached to the object. We assume that the robot moves slowly enough that we can treat the combined robot and deformable object as quasi-static. Let the function $\DeformForwardFn(\robotconfig, \deformconfig, \robotvel)$ map the system configuration $(\robotconfig, \deformconfig)$ and robot movement $\robotvel$ to the corresponding deformable object movement $\deformvel$.

Similar to the previous chapter, we define a task based on a set of $\ntargetpoints$ target points $\target \subset \reals^3$, a function $\ErrorFnFull \rightarrow \reals^{\geq 0}$, which measures the alignment error between $\deformconfig$ and $\target$, and a termination function $\TermCondFull$ which indicates if the task is finished. Let a robot controller be a function $\CtrlFull$\footnote{A specific controller may have additional parameters (such as gains in a PID controller), but we do not include such parameters here to keep $\Ctrl(\dots)$ in a more general form.} which maps the system state $\left( \robotconfig, \deformconfig \right)$ and alignment targets $\target$ to a desired robot motion $\robotvelcmd$. In this work we restrict our discussion to tasks and controllers of the form introduced in Chapter~\ref{chap:local_control}; these controllers are local, i.e. at each time $t$ they choose an incremental movement $\robotvelcmd$ which reduces the alignment error as much as possible at time $t + 1$. 

The problem we address in this chapter is how to find a sequence of $\taskexecutiontime$ robot commands $\robotvelcmdexpanded = \robotvelcmdseq$ such that each motion is feasible, i.e. it should not bring the grippers into collision with obstacles, should not cause the object to stretch excessively, and should not exceed the robot's maximum velocity $\robotvelmax$. Let these feasibility constraints be represented by $A(\robotvelcmdseq) = 0$. Then the problem we seek to solve is:
\begin{equation}
    \begin{aligned}
        & \text{find}   & & \taskexecutiontime, \robotvelcmdseq \\
        & \text{s.t.}   & & \TermCond(\target, \deformconfig_{\taskexecutiontime}) = \texttt{true}\\ 
        &               & & A(\robotvelcmdseq) = 0\\
    \end{aligned}
    \label{eqn:veb_general_problem}
\end{equation}
where $\deformconfig_{\taskexecutiontime}$ is the configuration of the deformable object after executing $\robotvelcmdseq$.

Solving this problem directly is impractical in the general case for two major reasons. First, modeling a deformable object accurately is very difficult in the general case, especially if it contacts other objects or itself. Second, even given a perfect model, computing precise motion of the deformable object requires physical simulation, which can be very time consuming inside a planner/controller where many potential movements need to be evaluated. We seek a method which does not rely on high-fidelity modelling and simulation; instead we present a framework combining both global planning and local control to leverage the strengths of each in order to efficiently perform the task.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{2_interleaving}
\FloatBarrier

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{3_planning}
\FloatBarrier

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{4_planning_analysis}
\FloatBarrier

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{5_experiments}
\FloatBarrier

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Discussion}
\label{sec:planning_discussion}

We have presented a method to interleave global planning and local control for deformable object manipulation that does not rely on high-fidelity modeling or simulation of the object. Our method combines techniques from topologically-based motion planning with a sampling-based planner to generate gross motion of the deformable object. The purpose of this gross motion is not to achieve the task alone, but rather to move the object into a position from which the local controller is able to complete the task. This division of labor enables each component to focus on their strengths rather than attempt to solve the entire problem directly. We also presented a probabilistic completeness proof for our planner which does not rely on either a steering function or choosing controls at random, and addresses our underactuated system. As part of our framework, we introduced a novel deadlock prediction algorithm to determine when to use the local controller and when to use the global planner.

Our experiments demonstrate that our framework is able to be applied to several interesting tasks for rope and cloth, including an adversarial case where we set up the planner to fail on the first attempt. For the simulated tasks, our framework is able to succeed at each task 100/100 times, with average planning and smoothing time under 4 seconds for 3 tasks, and under 11 seconds for the larger environment. The physical robot experiment shows that our framework can be used for practical tasks in the real world, with planning and smoothing taking less than 60 seconds on average. This experiment also shows that our methods can function despite noisy and occluded perception of the deformable object.

\subsection{Parameter Selection}
There are several parameters in both the local controller and the global planner that can have a large impact on the performance of our method. In particular, if the local controller is prone to oscillations, this can cause the deadlock prediction algorithm to incorrectly predict that the local controller will get stuck, leading to an unnecessary planning phase. In the worse case, this can cause the global planner to be unable to find an acceptable path due to the blacklisting procedure. One interesting direction of future research is how to perform reachability analysis for deformable objects in general, in particular when a high-fidelity model of the deformable object is not available. In practice we found that increasing the prediction horizon $\predictionhorizon$ and prediction annealing factor $\bandlengthannealing$ was not useful as the prediction accuracy degrades quickly. We did have to tune the history window $\historywindow$ and thresholds $\errorprogressthreshold$, $\motionprogressthreshold$ against each other. Error improvement threshold $\errorprogressthreshold$ needs to be set relative to the definition of task error $\ErrorFn$, while $\motionprogressthreshold$ is more sensitive to oscillations. If $\motionprogressthreshold$ is too small, then the system will fail to detect that the controller is stuck in a poor local minima. If these thresholds are too high or $\historywindow$ is too low, then false positives were common near the end of the table coverage tasks.

For the global planner, we found that the goal bias $\goalbias$ has a similar effect on planning time as a standard RRT; values in the range $[0.05, 0.15]$ produced similar planning times for our experiments. In addition, if $\banddistscale$ is not small, then nearest neighbour checks can become very expensive. In practice distances in band space are used to disambiguate between nodes that are at nearly identical configurations in robot configuration space. This happens when multiple nodes connect to the position goal $\eepositiongoal$, but their bands are similar to a blacklisted band. One potential way to make distances in band space more informative would be to develop a way to sample interesting band configurations.

\subsection{Limitations}
We made a choice to favor speed over model accuracy. As a consequence, there are several issues that our method does not address. In particular environments with ``hooks'' can cause problems due to our approximation methods; the virtual elastic band we use for constraint checking and planning assumes (1) that there is no minimum length of the deformable object and (2) there are no holes in the deformable object. These assumptions mean that our planner cannot detect cases where the slack material or a hole can get snagged on corners or hooks, preventing the motion plan from being executed. One way this can be mitigated is by using a more accurate model (at the cost of speed and task-specific tuning). Other potential solutions include online modeling methods such as~\cite{Hu2018deformable_gpr}, or learning which features of the workspace can lead to highly inaccurate approximations and planning paths that avoid those areas. In addition we have no explicit method to avoid twisting or knot-tying behavior. While shortcut smoothing can potentially mitigate the worst effects, avoiding such cases is not something that is within the scope of this work. Similarly, we don't have any explicit consideration for achieving a task that requires knot-tying or twisting; while some other local controller may be able to perform these tasks from a suitable starting state, we have not investigated this option. Last, we cannot guarantee that we can achieve any given task in general; while our blacklisting method is designed to encourage exploration of the state space, it also has the potential to block regions of the state space from which the local controller can achieve the task. Defining a set of tasks which our framework can successfully perform is not practical given the limited set of assumptions we are making about the deformable object. Despite these limitations we find that our framework is able to reliably perform complex tasks where neither planning nor control alone are sufficient. 
