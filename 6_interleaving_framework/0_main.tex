\chapter{Interleaving Planning and Control}
\label{chap:interleaving}

The previous chapters have focused on local methods for solving tasks. While we've shown that these methods are capable of performing interesting tasks, they are unable to escape from local minima due to their very design. This chapter is focused on a method to overcome this limitation by adding planning to the set of tools that we can apply to a given task.

One of the challenges in planning for deformable object manipulation is the high number of degrees of freedom involved; even approximating the configuration of a piece of cloth in 3D with a 4 $\times$ 4 grid results in a 48 degree of freedom configuration space. In addition, the dynamics of the deformable object are difficult to model \citep{Essahbi2012}; even with high-fidelity modeling and simulation, planning for an individual task can take hours \citep{Bai2016}. Local controllers on the other hand are able to very efficiently generate motion, however, they are only able to successfully complete a task when the initial configuration is in the ``attraction basin'' of the goal as seen in Chapter~\ref{chap:local_control}.

\begin{figure*}[t]
    \centering
    \includegraphics[trim={5cm 6cm 3cm 4cm},clip,width=0.24\textwidth,height=1.5in,keepaspectratio]{single_pole_starting_configuration}\hfill
    \includegraphics[trim={2cm 3cm 6cm 7cm},clip,width=0.24\textwidth,height=1.5in,keepaspectratio]{double_slit_starting_configuration}\hfill
    \includegraphics[trim={0cm 1cm 0cm 1cm},clip,width=0.24\textwidth,height=1.5in,keepaspectratio]{rope_maze_starting_configuration}\hfill
    \includegraphics[trim={1.5cm 0cm 0.6cm 0cm},clip,width=0.24\textwidth,height=1.5in,keepaspectratio]{live_robot_starting_configuration}%
    \caption{Four example manipulation tasks for our framework. In the first two tasks, the objective is to cover the surface of the table (indicated by the red lines) with the cloth (shown in green). In the first task, the grippers (shown in blue) can freely move however the cloth is obstructed by a pillar. In the second task, the grippers must pass through a narrow passage before the table can be covered. In the third task, the robot must navigate a rope (shown in green in the top left corner) through a three-dimensional maze before covering the red points in the top right corner. The maze consists of top and bottom layers (purple and green, respectively). The rope starts in the bottom layer and must move to the target on the top layer through an opening (bottom left or bottom right). For the fourth task, the physical robot must move the cloth from the far side of an obstacle to the region marked in pink near the base of the robot.}
    \label{fig:example_tasks}
\end{figure*}

The central question we address in this work is how can we combine the strengths of global planning with the strengths of local control while mitigating the weakness of each? We propose a framework for interleaving planning and control which uses global planning to generate gross motion of the deformable object, and a local controller to refine the configuration of the deformable object within the local neighborhood. By separating planning from control we are able to use different representations of the deformable object, each suited to efficient computation for their respective roles. In order to determine when to use each component, we introduce a novel deadlock prediction algorithm that is inspired by topologically-based motion planning methods \citep{Bhattacharya2012,Jaillet2008}. By answering the question ``Will the local controller get stuck?'' we can predict if the local controller will be unable to achieve the task from the current configuration. If we predict that the controller will get stuck we can then invoke the global planner, moving the deformable object into a new neighbourhood from which the local controller may be able to succeed. The key to our efficient prediction is forward-propagating only the stretching constraint, assuming the object will otherwise comply to contact.

We seek to solve problems for one-dimensional and two-dimensional deformable objects (i.e. rope and cloth) where we need to arrange the object in a particular way (e.g. covering a table with a tablecloth) but where there is also complex environment geometry preventing us from directly completing the task. While we cannot claim to solve all problems in this class (in particular in environments where the deformable object can be snagged), we can still solve practical problems where the path of the deformable object is obstructed by obstacles. In this work we restrict our focus to controllers of the form described in Section~\ref{sec:local_control}, and tasks suited to these controllers. Examples of these types of tasks are shown in Figure~\ref{fig:example_tasks}. In our experiments we show that this iterative method of interleaving planning and control is able to successfully perform several interesting tasks where our planner or controller alone are unable to succeed.

Our contributions are: (1) A novel deadlock prediction algorithm to determine when a global planner is needed; (2) An efficient and probabistically-complete global planner for rope and cloth manipulation tasks; and (3) A framework to combine local control and global motion planning to leverage the strengths of each while mitigating their weaknesses. We present experiments in both a simulated environment and on a physical robot (Figure~\ref{fig:example_tasks}). Our results suggest that our planner can efficiently find paths, taking under a second on average to generate a feasible path in three out of four simulated scenarios. The physical experiment shows that our framework is able to effectively perform tasks in the real world, where reachability and dual-arm constraints make the planning more difficult.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Problem Statement}
\label{sec:main_problem_statement}

\todoin{This duplicates some previous stuff. Refer back or keep here?}
Define the robot configuration space to be $\robotCspace$. We assume that the robot configuration can be measured exactly. Denote an individual robot configuration as $\robotconfig \in \robotCspace$. This set can be partitioned into a valid and invalid set. The valid set is referred to as $\robotCvalid$, and is the set of configurations where the robot is not in collision with the static geometry of the world. The invalid set is referred to as $\robotCinvalid = \robotCspace \setminus \robotCvalid$.

\todoin{Confirm the `previous chapters' statement.}
We assume that our model of the robot is purely kinematic, with no higher order dynamics. Previous chapters assumed an arbitrary number of grippers; in this chapter we restrict the problem to cases where two end-effectors that are rigidly attached to the object. We assume that the robot moves slowly enough that we can treat the combined robot and deformable object as quasi-static. Let the function $\DeformForwardFn(\robotconfig, \deformconfig, \robotvel)$ map the system configuration $(\robotconfig, \deformconfig)$ and robot movement $\robotvel$ to the corresponding deformable object movement $\deformvel$.

Similar to the previous chapter, we define a task based on a set of $\ntargetpoints$ target points $\target \subset \reals^3$, a function $\ErrorFnFull \rightarrow \reals^{\geq 0}$, which measures the alignment error between $\deformconfig$ and $\target$, and a termination function $\TermCondFull$ which indicates if the task is finished. Let a robot controller be a function $\CtrlFull$\footnote{A specific controller may have additional parameters (such as gains in a PID controller), but we do not include such parameters here to keep $\Ctrl(\dots)$ in a more general form.} which maps the system state $\left( \robotconfig, \deformconfig \right)$ and alignment targets $\target$ to a desired robot motion $\robotvelcmd$. In this work we restrict our discussion to tasks and controllers of the form introduced in Chapter~\ref{chap:local_control}; these controllers are local, i.e. at each time $t$ they choose an incremental movement $\robotvelcmd$ which reduces the alignment error as much as possible at time $t + 1$. 

The problem we address in this chapter is how to find a sequence of $\taskexecutiontime$ robot commands $\robotvelcmdexpanded = \robotvelcmdseq$ such that each motion is feasible, i.e. it should not bring the grippers into collision with obstacles, should not cause the object to stretch excessively, and should not exceed the robot's maximum velocity $\robotvelmax$. Let these feasibility constraints be represented by $A(\robotvelcmdseq) = 0$. Then the problem we seek to solve is:
\begin{equation}
    \begin{aligned}
        & \text{find}   & & \taskexecutiontime, \robotvelcmdseq \\
        & \text{s.t.}   & & \TermCond(\target, \deformconfig_{\taskexecutiontime}) = \texttt{true}\\ 
        &               & & A(\robotvelcmdseq) = 0\\
    \end{aligned}
    \label{eqn:veb_general_problem}
\end{equation}
where $\deformconfig_{\taskexecutiontime}$ is the configuration of the deformable object after executing $\robotvelcmdseq$.

Solving this problem directly is impractical in the general case for two major reasons. First, modeling a deformable object accurately is very difficult in the general case, especially if it contacts other objects or itself. Second, even given a perfect model, computing precise motion of the deformable object requires physical simulation, which can be very time consuming inside a planner/controller where many potential movements need to be evaluated. We seek a method which does not rely on high-fidelity modelling and simulation; instead we present a framework combining both global planning and local control to leverage the strengths of each in order to efficiently perform the task.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{2_interleaving}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{3_planning}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{4_planning_analysis}
\input{5_experiments}
