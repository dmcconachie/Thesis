\section{Stretching Avoidance Controller}
\label{sec:stretching_avoidance_controller}

\begin{algorithm}[ht]
    \caption{StretchingAvoidanceController$(\gripperconfig, \deformconfig, \target)$}
    \begin{algorithmic}[1]
        \State $\correspondences \gets$ CalculateCorrespondences$(\deformconfig, \target)$
        \State $\deformvel_e, \Pinvweight_e \gets$ FollowNavigationFunction$(\deformconfig, \correspondences)$
        \State $\deformvel_s, \Pinvweight_s \gets$ StretchingCorrection$(\deformconfig)$
        \State $\deformvel_d, \Pinvweight_d \gets$ CombineTerms$(\deformvel_e, \Pinvweight_e, \deformvel_s, \Pinvweight_s)$
        \State $\grippervel \gets$ FindBestRobotMotion$(\gripperconfig, \deformconfig, \deformvel_d, \Pinvweight_d)$
    \end{algorithmic}
    \label{alg:stretching_avoidance_controller}
\end{algorithm}

An outline of how this controller functions is shown in Alg.~\ref{alg:stretching_avoidance_controller}; first, we calculate the error reduction direction and weight as discussed in the previous section (Lines 1 and 2). These error reduction terms are then combined with stretching avoidance terms $\deformvel_s, \Pinvweight_s$ to define the desired manipulation direction and importance weights $\deformvel_d, \Pinvweight_d$ at each timestep (Lines 3 and 4). We then find the best robot motion to achieve the desired deformable object motion, while preventing collision between the robot and obstacles (Line 5).

\subsection{Stretching correction}
\label{sec:stretching_correction}

\begin{algorithm}[ht]
\caption{StretchingCorrection$(\deformconfig)$}
\begin{algorithmic}[1]
    \State $E \gets$ EuclidianDistanceMatrix$(\deformconfig)$
    \State $\deformvel_s \gets \zero_{\deformCspacesize \times 1}$
    \State $\Pinvweight_s \gets \zero_{\ndeformpoints \times 1}$
    \For{$\deformidx \in \{1,2,\dots,\ndeformpoints \}$}
        \For{$j \in \text{Neighbours}(i)$}
            \If{$\deformidx < j$ \textbf{and} $E_{\deformidx j} > \stretchmax \geodistIJ$}
                \State $\Delta_{\deformidx j} \gets E_{\deformidx j} - \geodistIJ$
                \State $v \gets \Delta_{\deformidx j}(\deformconfigJ - \deformconfigI)$
                \State $\deformvelIpre{s} \gets \deformvelIpre{s} + \frac{1}{2}v$
                \State $\deformvelJpre{s} \gets \deformvelJpre{s} - \frac{1}{2}v$
                \State $\PinvweightIpre{s} \gets \max (\PinvweightIpre{s}, \Delta_{\deformidx j})$
                \State $\PinvweightJpre{s} \gets \max (\PinvweightJpre{s}, \Delta_{\deformidx j})$
            \EndIf
        \EndFor
    \EndFor
    \State \Return $\deformvel_s, \Pinvweight_s$
\end{algorithmic}
\label{alg:stretching_correction_ijrr}
\end{algorithm}

\begin{algorithm}[ht]
\caption{CombineTerms$(\deformvel_e, \Pinvweight_e, \deformvel_s, \Pinvweight_s)$}
\begin{algorithmic}[1]
    \For{$\deformidx \in \{ 1,2,\dots,\ndeformpoints \}$}
        \State $\deformvelIpre{d} \gets \deformvelIpre{s} + \left( \deformvelIpre{e} - \proj_{\deformvelIpre{s}} \deformvelIpre{e} \right)$
        \State $\PinvweightIpre{d} \gets \stretchweightfactor \PinvweightIpre{s} + \PinvweightIpre{e}$
    \EndFor
    \State \Return $\deformvel_d, \Pinvweight_d$
\end{algorithmic}
\label{alg:combine_terms}
\end{algorithm}


Our algorithm for stretching correction is similar to that found in~\cite{Berenson2013}, with the addition of a weighting term $\stretchweightfactor$, and a change in how we combine error correction and stretching correction. We use the StretchingCorrection() function (Alg.~\ref{alg:stretching_correction}) to compute $\deformvel_s$ and $\Pinvweight_s$ based on a task-defined stretching threshold $\Pinvweight_s \geq 0$. First we compute the distance between every two points on the object and store the result in $E$. We then compare $E$ to $\geodist$ which contains the relaxed lengths between every pair of points. If any two neighbouring points are stretched by more than a factor of $\Pinvweight_s$, we attempt to move the points closer to each other. We use the same strategy for setting the importance of this stretching correction $\Pinvweight_s$ as we use for error correction. When combining stretching correction and error correction terms (Alg.~\ref{alg:combine_terms}) we prioritize stretching correction, accepting only the portion of the error correction that is orthogonal to the stretching correction term for each point. $\stretchweightfactor$ is used to define the relative scale of the importance factors $\Pinvweight_e$ and $\Pinvweight_s$



\subsection{Finding the best robot motion}

\todoin{Cleanup $\JacobianFull$ vs $J$ vs $J_d$ vs $J_r$ in this section.}

Given a desired deformable object velocity $\deformvel_d$ and relative importance weights $\Pinvweight_d$, we want to find the robot motion that best achieves $(\deformvel_d, \Pinvweight_d$). I.e.
\begin{equation}
\begin{aligned}
    & \argmin_{\robotvel} 
        & & \| \DeformForwardFnFull - \deformvel_d \|_{\Pinvweight_d} \\
    & \text{subject to}
        & & \| \robotvel \| \leq \robotvelmax \\
    &   & & \left(\robotconfig + \robotvel \right) \in \robotCvalid \enspace .
\end{aligned}
\label{eqn:controller_minimization_problem_apx}
\end{equation}
In general, $\DeformForwardFn(\dots)$ is not known. For our stretching avoidance controller we use a Jacobian based approximation (Sec.~\ref{sec:jacobian_models}):
\begin{equation}
    \DeformForwardFnFull \approx \JacobianFull \robotvel
\end{equation}
Our method for ensuring the robot stays in $\robotCvalid$ is different, depending on which robot we are using.


\subsubsection{Simulated experiments:}

For the simulated experiments, we first solve Eq.~\eqref{eqn:controller_minimization_problem_apx} using our Jacobian approximation while neglecting the collision constraints:
\begin{equation}
\begin{aligned}
    \DeformBackwardFn_{\tanse3}(\deformvel, \Pinvweight) =
        &\argmin_{\grippervel }
            & & \| J \grippervel - \deformvel \|_{\Pinvweight} \\
        &\textrm{subject to}
            & & \grippervelGnorm \leq \grippervelmaxservo \enspace, \quad \gripperidx = 1, \dots, \ngrippers
    \label{eqn:jacobianbackwardfunction_sim}
\end{aligned}
\end{equation}
where $\grippervelmaxservo$ is the maximum velocity for each individual gripper.
% (Alg.~\ref{alg:find_best_robot_motion_simulation}).

In order to guarantee that the grippers do not collide with any obstacles, we use the same strategy from~\cite{Berenson2013}, smoothly switching between collision avoidance and other objectives (see Alg.~\ref{alg:obstaclerepulsion}). For every gripper $\gripperidx$ and an obstacle set $\obstacle$ we find the distance $d_\gripperidx$ to the nearest obstacle, a unit vector $\dot x_{p_\gripperidx}$ pointing from the obstacle to the nearest point on the gripper, and a Jacobian $J_{p^\gripperidx}$ between the gripper's DoF and the point on the gripper as shown in Alg.~\ref{alg:proximity}. We then project the servoing motion from Eq.~\eqref{eqn:jacobianbackwardfunction_sim} into the null space of the avoidance motion using the null space projector $\left(\eye - J_{p^g}^+ J_{p^g} \right)$. $\obsavoidfactor > 0$ sets the rate at which we change between servoing and collision avoidance objectives. $\grippervelmaxobs > 0$ is an internal parameter that sets how quickly we move the robot away from obstacles.





\begin{algorithm}[ht]
\caption{FindBestRobotMotionSim$(\gripperconfig, \deformconfig, \deformvel_d, \Pinvweight_d)$}
\label{alg:find_best_robot_motion_simulation}
\begin{algorithmic}[1]
    \State $\grippervelS \gets \DeformBackwardFn_{\tanse3} (\deformvel_d, \Pinvweight_d)$ \hfill Eq.~\eqref{eqn:jacobianbackwardfunction_sim}
    \State $\grippervelcmd \gets $ ObstacleRepulsion$(\grippervelS, \obstacle)$
    \State \Return $\grippervelcmd$
\end{algorithmic}
\end{algorithm}

\todoin{Clean up inputs etc. - $q$ is needed for repulsion, proximity etc.}

\begin{algorithm}[ht]
\caption{ObstacleRepulsion$(\grippervelS, \obstacle)$}
\begin{algorithmic}[1]
    \For{$\gripperidx \in \{1, \dots, \ngrippers \}$}
        \State $J_{p^\gripperidx}, \dot x _{p^\gripperidx}, d_\gripperidx \gets$ Proximity$(\gripperconfigG, \obstacle)$
        \State $\lambda \gets e^{-\obsavoidfactor d_\gripperidx}$
        \State $v \gets J_{p^\gripperidx}^+ \dot x_{p^\gripperidx}$
        \State $\grippervelGC \gets \grippervelmaxobs \frac{v}{\| v \|}$
        \State $\grippervelG \gets$ $\lambda \left( \grippervelGC + \left( \eye - J_{p^\gripperidx}^+ J_{p^\gripperidx} \right) \grippervelGS \right) + (1-\lambda) \grippervelGS$
    \EndFor        
    \State \Return $\grippervel$
\end{algorithmic}
\label{alg:obstaclerepulsion}
\end{algorithm}


\begin{algorithm}[ht]
\caption{Proximity$(\gripperconfigG, \obstacle)$}
\label{alg:proximity}
\begin{algorithmic}[1]
    \State $d_\gripperidx \gets \infty$
    \For{$o \in \{1,2,\dots,|\obstacle|\}$}
        \State $p^\gripperidx, p^o \gets$ ClosestPoints$(\gripperconfigG, o)$
        \State $v \gets p^\gripperidx - p^o$
        \If{$\| v \| < d_\gripperidx$}
            \State $d_\gripperidx \gets \| v \|$
            \State $\dot x_{p^\gripperidx} \gets \frac{v}{\| v \|}$
            \State $J_{p^\gripperidx} \gets$ RobotPointJacobian$(\gripperconfigG, p^\gripperidx)$
        \EndIf
    \EndFor
    \State \Return $J_{p^\gripperidx}, \dot x_{p^\gripperidx}, d_\gripperidx$
\end{algorithmic}
\end{algorithm}



\subsubsection{Physical experiments:}
\label{sec:stretching_avoidance_controller_physical_robot_implementation}

\todoin{Clean up $J_{p^g}$ vs $J_{c_i}$ etc. throughout this section. And $J_d, J_r$.}

\begin{algorithm}[ht]
\caption{FindBestRobotMotionPhys$(\gripperconfig, \deformconfig, \deformvel_d, \Pinvweight_d)$}
\label{alg:find_best_robot_motion_physical}
\begin{algorithmic}[1]
    \For {$\gripperidx \in \{ 1, 2, \dots, | \mathcal{C} | \}$}
        \State $J_{p^\gripperidx}, \dot x _{p^\gripperidx}, d_\gripperidx \gets$ Proximity$(\obstacle, \gripperidx)$
    \EndFor
    \State $\robotvelcmd \gets \DeformBackwardFn_{\physrobotVspace} (\deformvel_d, \Pinvweight_d)$ \hfill Eq.~\eqref{eqn:jacobianbackwardfunction_live}
\end{algorithmic}
\end{algorithm}

For the physical robot, instead of handling collision avoidance in a post-processing step, we build the collision constraints directly into the optimization function (Alg.~\ref{alg:find_best_robot_motion_physical}). To do so, we define a set of points  $\mathcal{C} = \{c_1, c_2, \dots \}$ on the robot that must stay at least $\dbuffer$ away from obstacles. In our implementation, this is the end-effectors, wrists, and elbows of each arm of the robot. We then use the same Proximity() function\todo{it's not quite the same} (Alg.~\ref{alg:proximity}) as the simulated robot to define an extra constraint that must be satisfied:
\begin{equation}
\begin{aligned}
    \DeformBackwardFn_{\reals^N}(\deformvel, \Pinvweight) = 
        &\argmin_{\robotvel}    & & \| J_d \grippervel - \deformvel \|^2_{\Pinvweight} \\
        &\text{subject to}      & & \hspace{1.2cm} \llap{$\robotconfig + \robotvel$} \in \robotCvalid \\
        &                       & & \hspace{1.2cm} \llap{$\| \robotvel \|$}          \leq \physrobotvelmax \\
        &                       & & \hspace{1.2cm} \llap{$\| J_{r,\gripperidx} \robotvel \|$}  \leq \grippervelmaxservo \enspace , \quad g = 1, \dots, \ngrippers \\
        &                       & & \hspace{1.2cm} \llap{$\dot x_{c_i}^T J_{c_i} \grippervel$} \leq d_{c_i} + \dbuffer \enspace , \quad i = 1, \dots, |\mathcal{C}| \enspace .
\label{eqn:jacobianbackwardfunction_live}
\end{aligned}
\end{equation}
In addition, we constrain the velocity of the robot both in joint configuration space 
$$ \| \grippervel \| \leq \physrobotvelmax $$
and the velocity of the end-effectors in $\se3$ 
$$ \| J_{r,\gripperidx} \grippervel \| \leq \grippervelmaxservo $$
where $J_{r,\gripperidx}$ is the Jacobian between robot motion and end effector motion for gripper $\gripperidx$.

To solve Equations \eqref{eqn:jacobianbackwardfunction_sim} and \eqref{eqn:jacobianbackwardfunction_live} we use the Gurobi optimizer (\cite{Gurobi2016}). Table~\ref{tab:controller_param_table} shows the parameters we use for each experiment.


% Given the current system state $(\gripperconfig, \deformconfig)$ FindBestRobotMotion$(\gripperconfig, \deformconfig, \deformvel_d, \Pinvweight_d)$ is solving the following problem:
% \begin{equation}
% \begin{aligned}
%     & \argmin_{\grippervel } 
%         & & \| \deformforwardfn(\grippervel) - \deformvel_d \|_{\Pinvweight_d} \\
%     &\text{subject to}
%         & & \| \grippervel \| \leq \maxrobotvel \\
%     &   & & \left(\gripperconfig + \grippervel\right) \in \cfree_r \enspace .
% \end{aligned}
% \label{eqn:controller_minimization_problem}
% \end{equation}
 